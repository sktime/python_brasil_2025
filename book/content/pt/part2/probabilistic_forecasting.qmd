# Forecast probabilístico

## 2.4. Probabilistic forecasting

When forecasting for retail, we often interested in the uncertainty of the forecasts.

* Safety stock
* Predict probability of stockouts

```{python}
from sktime.registry import all_estimators

all_estimators("forecaster", filter_tags={"capability:pred_int": True}, as_dataframe=True)
```

```{python}
from sktime.forecasting.auto_reg import AutoREG
from sktime.transformations.series.difference import Differencer
from sktime.transformations.series.fourier import FourierFeatures
from sktime.forecasting.conformal import ConformalIntervals

fourier_features = FourierFeatures(
    sp_list=[365.25, 365.25 / 12], fourier_terms_list=[1, 1], freq="D"
)
auto_reg = fourier_features ** (Differencer() * AutoREG())


conformal_forecaster = ConformalIntervals(
    forecaster=auto_reg, initial_window=365 * 2, sample_frac=0.5
)
```

```{python}
parallel_config = {
        "backend:parallel": "joblib",
        "backend:parallel:params": {"backend": "loky", "n_jobs": -1},
    }

conformal_forecaster.set_config(
    **parallel_config
)

conformal_forecaster.fit(y_train)
```

```{python}
y_pred_int = conformal_forecaster.predict_interval(fh=fh, coverage=0.9)
```

```{python}
y_pred_int
```

```{python}
plot_series(
    y_train.loc[10], y_test.loc[10], labels=["Train", "Test"], title="Panel data",
    pred_interval=y_pred_int.loc[10], markers=[None]*2
)
```

There are negative values in the data, which do not make sense for our problem.

We can use a model that predicts a distribution that does not allow negative values, such as the **negative binomial distribution**.

```{python}
from prophetverse import Prophetverse, PiecewiseLinearTrend, MAPInferenceEngine


prophet = Prophetverse(
    trend=PiecewiseLinearTrend(changepoint_interval=365),
    likelihood="negbinomial",
    inference_engine=MAPInferenceEngine()
)

prophet.set_config(
    **parallel_config
)

prophet.fit(y_train, X_train)
```

```{python}
y_pred_int_prophetverse = prophet.predict_interval(fh=fh, X=X_test, coverage=0.9)
```

```{python}
plot_series(
    y_train.loc[10], y_test.loc[10], labels=["Train", "Test"], title="Panel data",
    pred_interval=y_pred_int_prophetverse.loc[10], markers=[None]*2
)

plt.show()
```

### Example of metric for probabilistic forecasting

```{python}
from sktime.performance_metrics.forecasting.probabilistic import PinballLoss

pinball_loss = PinballLoss()

pd.DataFrame(
    {"Conformal": pinball_loss(y_true=y_test, y_pred=y_pred_int),
     "Prophetverse Negbinomial": pinball_loss(y_true=y_test, y_pred=y_pred_int_prophetverse)},
    index=["Pinball Loss"]
)
```

## 2.5. Deep learning models and zero-shot forecasting

* In addition to simple ML models, we can also use deep learning models for forecasting.
* There are some models with tailored architectures for time series forecasting.
* For example, N-BEATS is a deep learning model that can be used for forecasting.
  
* **Zero-shot forecasting** is extremely useful when a new product appears, a new warehouse... etc.
  
![](imgs/nbeats_simplified.png)

```{python}
from sktime.forecasting.pytorchforecasting import PytorchForecastingNBeats
from pytorch_forecasting.data.encoders import EncoderNormalizer

CONTEXT_LENGTH = 365
nbeats = PytorchForecastingNBeats(
    train_to_dataloader_params={"batch_size": 256},
    trainer_params={"max_epochs": 1},
    model_params={
        "stack_types": ["trend", "seasonality"], # One of the following values: “generic”, “seasonality” or “trend”.
        "num_blocks" : [2,2], # The number of blocks per stack. 
        "context_length": CONTEXT_LENGTH, # lookback period
        "expansion_coefficient_lengths" : [2, 5],
        "learning_rate": 1e-3,
    },
    dataset_params={

        "max_encoder_length": CONTEXT_LENGTH,
        "target_normalizer": EncoderNormalizer()
    },
)

nbeats.fit(y_train.astype(float), fh=fh)
```

```{python}
y_pred_nbeats = nbeats.predict(fh=fh, X=X_test)
```

```{python}
metric(y_true=y_test, y_pred=y_pred_nbeats, y_train=y_train)
```

```{python}
fig, ax = plt.subplots(figsize=(10, 4))
y_train.loc[10].plot(ax=ax, label="Train")
y_test.loc[10].plot(ax=ax, label="Test")
y_pred_nbeats.loc[10].plot(ax=ax, label="N-BEATS")
fig.show()
```

```{python}
new_y_train = (y_train.loc[0]**2 + y_train.loc[20]).astype(float)
new_y_test = (y_test.loc[0]**2 + y_test.loc[20]).astype(float)

# Plotting the new series
fig, ax = plt.subplots(figsize=(10, 4))
new_y_train["sales"].plot.line(ax=ax, label="New Train")
new_y_test["sales"].plot.line(ax=ax, label="New Test")
fig.show()
```

```{python}
y_pred_zeroshot = nbeats.predict(fh=fh, y=new_y_train)
```

```{python}
fig, ax = plt.subplots(figsize=(10, 4))
new_y_train["sales"].plot.line(ax=ax, label="New Train")
new_y_test["sales"].plot.line(ax=ax, label="New Test")
y_pred_zeroshot["sales"].plot.line(ax=ax, label="N-BEATS Zero-shot")
plt.legend()
plt.show()
```

